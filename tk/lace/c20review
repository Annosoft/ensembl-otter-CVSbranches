#!/usr/local/bin/perl5.6.1 -w

### c20review

use strict;
use GenomeCanvas;
use Hum::Submission 'prepare_statement';
use Hum::AnaStatus::Sequence;
use Hum::Conf qw{ HUMACESERVER_HOST HUMGIFACESERVER_PORT };
use GenomeCanvas::Band::SeqChooser;
use Bio::EnsEMBL::DBSQL::DBAdaptor;
use Carp;
use Getopt::Long 'GetOptions';

{
    my $host = 'ecs1b';
    my $db   = 'chr20';
    my $user = 'ensro';
    my $fpc  = 'chr20';
    my $help = 0;
    my($annotator);
    GetOptions(
        'help!'     => \$help,
        'user=s'    => \$annotator,
        ) or useage();
    useage() if $help;
    if ($annotator) {
        die "Invalid annotator '$annotator'" unless is_valid_annotator($annotator);
    }
    
    my $ensdb = Bio::EnsEMBL::DBSQL::DBAdaptor->new(
        -DBNAME => $db,
        -USER   => $user,
        -HOST   => $host,
        );
    
    my $mw = CanvasWindow::MainWindow->new;
    $mw->title($fpc);
    my $gc = GenomeCanvas->new($mw);
    my $chooser = GenomeCanvas::Band::SeqChooser->new;
    $gc->add_Band($chooser);
    $chooser->chooser_map(make_chooser_map($ensdb, $fpc));
    $gc->render;
    $gc->fix_window_min_max_sizes;
    
    my $canvas = $gc->canvas;
    $canvas->CanvasBind('<Button-1>', sub {
        deselect_all_selected_not_current($gc);
        toggle_current($gc);
        });
    $canvas->CanvasBind('<Shift-Button-1>', sub {
        toggle_current($gc);
        });
    
    {
        my( $comment );
        if ($annotator) {
            my $button_frame = $mw->Frame;
            $button_frame->pack(
                -side => 'top',
                );

            my $comment_label = $button_frame->Label(
                -text => 'Comment:',
                );
            $comment_label->pack(
                -side => 'left',
                );

            $comment = $button_frame->Entry(
                -width => 55,
                );
            $comment->pack(
                -side => 'left',
                );
        }
        
        
        my $button_frame2 = $mw->Frame;
        $button_frame2->pack(
            -side => 'top',
            );
        
        if ($annotator) {
            my $set_reviewed = sub{
                my $c = $comment->get;
                my @ana_seq_id_list = list_selected_ana_seq_ids($canvas);
                return unless @ana_seq_id_list;
                set_reviewed($annotator, $c, @ana_seq_id_list);
                $chooser->chooser_map(make_chooser_map());
                $gc->set_window_size(1);
                $gc->render;
                $gc->fix_window_min_max_sizes
                };
            make_button($button_frame2, 'Set reviewed', $set_reviewed, 0);
            $mw->bind('<Control-s>', $set_reviewed);
            $mw->bind('<Control-S>', $set_reviewed);
        }
        
        my $hunter = sub{
            watch_cursor($mw);
            hunt_for_selection($gc);
            default_cursor($mw);
            };
        
        # First call to this returns empty list!
        my @all_text_obj = $canvas->find('withtag', 'contig_text');
        
        make_button($button_frame2, 'Hunt selection', $hunter, 0);
        $mw->bind('<Control-h>', $hunter);
        $mw->bind('<Control-H>', $hunter);
        
        my $refesher = sub{
            watch_cursor($mw);
            $chooser->chooser_map(make_chooser_map());
            $gc->set_window_size(1);
            $gc->render;
            $gc->fix_window_min_max_sizes;
            default_cursor($mw);
            };
        make_button($button_frame2, 'Refresh', $refesher, 0);
        $mw->bind('<Control-r>', $refesher);
        $mw->bind('<Control-R>', $refesher);
        $mw->bind('<F5>', $refesher);

        if ($annotator) {
            my $run_lace = sub{
                watch_cursor($mw);
                my @sequence_name_list = list_selected_sequence_names($canvas);
                return unless @sequence_name_list;
                fork_lace_process(@sequence_name_list);
                default_cursor($mw);
                };
            make_button($button_frame2, 'Run lace', $run_lace, 4);
            $mw->bind('<Control-l>', $run_lace);
            $mw->bind('<Control-L>', $run_lace);
            
            my $do_embl_dump = sub{
                watch_cursor($mw);
                my @sequence_name_list = list_selected_sequence_names($canvas);
                foreach my $seq (@sequence_name_list) {
                    do_embl_dump($seq);
                }
                default_cursor($mw);
                };
            make_button($button_frame2, 'EMBL dump', $do_embl_dump, 0);
            $mw->bind('<Control-e>', $do_embl_dump);
            $mw->bind('<Control-E>', $do_embl_dump);
        }
        
        make_button($button_frame2, 'Quit', sub{ Tk::exit() }, 0);
    }
    
    ###############
    Tk::MainLoop();
    ###############
}

sub watch_cursor {
    my( $w ) = @_;
    
    $w->configure( -cursor => 'watch' );
    $w->update;
}

sub default_cursor {
    my( $w ) = @_;
    
    $w->configure( -cursor => undef );
    $w->update;
}

{
    my( %lace_dir );

    sub fork_lace_process {
        my( @seq_name_list ) = @_;

        # Record the lace db directory of each
        # of the sequences.
        my $lace_dir = (getpwuid($<))[7] . '/.lace';
        my $lace_dir_suffix = "_${HUMACESERVER_HOST}_$HUMGIFACESERVER_PORT";
        my $lace_seq_home = "$lace_dir/$seq_name_list[0]$lace_dir_suffix";
        foreach my $seq (@seq_name_list) {
            $lace_dir{$seq} = $lace_seq_home;
        }

        if (my $pid = fork) {
            $SIG{'CHLD'} = 'IGNORE';
            sleep 15;   # Prevent multiple button presses
            return 1;
        }
        elsif (defined $pid) {
            exec('lace', '-noacetmp', @seq_name_list);
        }
        else {
            die "Error: Can't fork : $!";
        }
    }
    
    sub do_embl_dump {
        my( $sequence_name ) = @_;
        
        my $ana_seq = Hum::AnaStatus::Sequence->new_from_sequence_name($sequence_name);
        my $ana_dir = $ana_seq->analysis_directory;
        my @embl_dump_command = ('emblDump', '-dump', $ana_dir, $sequence_name);
        if (my $lace_dir = $lace_dir{$sequence_name}) {
            push(@embl_dump_command, '-path', $lace_dir);
        }
        warn "Running '@embl_dump_command'\n";
        system(@embl_dump_command) == 0
            or die "Error running : '@embl_dump_command'";
    }
}

sub hunt_for_selection {
    my( $gc ) = @_;
    
    my $canvas = $gc->canvas;
    
    my( $query_str );
    eval {
        $query_str = $canvas->SelectionGet;
    };
    return if $@;
    #warn "Looking for '$query_str'";
    my $matcher = make_matcher($query_str);
    
    my $current_obj;
    foreach my $obj ($canvas->find('withtag', 'selected')) {
        $current_obj ||= $obj;
        toggle_selection($gc, $obj);
    }
    
    my $selected_text_obj = $canvas->selectItem;
    my @all_text_obj = $canvas->find('withtag', 'contig_text');
    if ($selected_text_obj) {
        if ($selected_text_obj == $all_text_obj[$#all_text_obj]) {
            # selected obj is last on list, so is to leave at end
        } else {
            for (my $i = 0; $i < @all_text_obj; $i++) {
                if ($all_text_obj[$i] == $selected_text_obj) {
                    my @tail = @all_text_obj[$i + 1 .. $#all_text_obj];
                    my @head = @all_text_obj[0 .. $i];
                    @all_text_obj = (@tail, @head);
                    last;
                }
            }
        }
    }

    my $found = 0;
    foreach my $obj (@all_text_obj) {
        my $text = $canvas->itemcget($obj, 'text');
        my $hit = &$matcher($text);
        if ($hit) {
            $canvas->selectClear;
            my $start = index($text, $hit);
            die "Can't find '$hit' in '$text'" if $start == -1;
            $canvas->selectFrom($obj, $start);
            $canvas->selectTo  ($obj, $start + length($hit) - 1);
            $found = $obj;
            last;
        }
    }
    
    unless ($found) {
        warn "Can't find '$query_str'\n";
        return;
    }
    
    $gc->scroll_to_obj($found);
    
    my @overlapping = $canvas->find('overlapping', $canvas->bbox($found));
    foreach my $obj (@overlapping) {
        my @tags = $canvas->gettags($obj);
        if (grep $_ eq 'contig_seq_rectangle', @tags) {
            unless (grep $_ eq 'selected', @tags) {
                toggle_selection($gc, $obj);
            }
        }
    }
}

sub make_matcher {
    my( $pattern ) = @_;
    
    # Escape non word characters
    $pattern =~ s{(\W)}{\\$1}g;
    
    my $matcher = eval "sub {
        my( \$text ) = \@_;
        
        \$text =~ /($pattern)/i;
        return \$1;
        }";
    if ($@) {
        die "Error in pattern '$pattern' \n$@";
    } else {
        return $matcher;
    }
}

sub list_selected_ana_seq_ids {
    my( $canvas ) = @_;
    
    my @selected_objects = $canvas->find('withtag', 'selected');
    my( @ana_seq_id_list );
    foreach my $obj (@selected_objects) {
        my ($ana_seq_id) = map /ana_seq_id=(\d+)/, $canvas->gettags($obj); 
        die "Found selected object without ana_seq_id" unless $ana_seq_id;
        push(@ana_seq_id_list, $ana_seq_id);
    }
    return @ana_seq_id_list;
}

sub list_selected_sequence_names {
    my( $canvas ) = @_;
    
    my @selected_objects = $canvas->find('withtag', 'selected');
    my( @sequence_name_list );
    foreach my $obj (@selected_objects) {
        my ($sequence_name) = map /sequence_name=(.+)/, $canvas->gettags($obj); 
        die "Found selected object without sequence_name" unless $sequence_name;
        push(@sequence_name_list, $sequence_name);
    }
    return @sequence_name_list;
}

sub set_reviewed {
    my( $user, $comment, @ana_seq_id ) = @_;

    foreach my $id (@ana_seq_id) {
        add_new_entry($id, $user, $comment);
    }
}

{
    my( $sth );
    
    sub add_new_entry {
        my( $id, $user, $comment ) = @_;
        
        $sth ||= prepare_statement(q{
            INSERT ana_sequence_review( ana_seq_id
                  , annotator_uname
                  , review_time
                  , review_comment)
            VALUES(?,?,NOW(),?)
            });
        $sth->execute($id, $user, $comment);
        $sth->rows or confess "Error inserting [$id, $user, $comment]";
    }
}


sub make_button {
    my( $parent, $label, $command, $underline_index ) = @_;
    
    my @args = (
        -text => $label,
        -command => $command,
        );
    push(@args, -underline => $underline_index)
        if defined $underline_index;
    my $button = $parent->Button(@args);
    $button->pack(
        -side => 'left',
        );
    return $button;
}

sub is_valid_annotator {
    my( $annotator ) = @_;

    my $sth = prepare_statement(q{
        SELECT annotator_uname
        FROM ana_person
        });
    $sth->execute;

    while (my( $db_ann ) = $sth->fetchrow) {
        return 1 if $db_ann eq $annotator;
    }
    return 0;
}


sub toggle_current {
    my( $gc ) = @_;
    
    my $canvas = $gc->canvas;
    
    my ($ana_seq) = grep /^ana_seq_id=/, $canvas->gettags('current');
    return unless $ana_seq;

    my ($rec) = $canvas->find('withtag', "$ana_seq&&contig_seq_rectangle");        
    toggle_selection($gc, $rec);
}

sub deselect_all_selected_not_current {
    my( $gc ) = @_;
    
    my $canvas = $gc->canvas;
    foreach my $obj ($canvas->find('withtag', 'selected&&!current')) {
        toggle_selection($gc, $obj);
    }
}

sub toggle_selection {
    my( $gc, $obj ) = @_;
    
    my $canvas = $gc->canvas;
    my $is_selected = grep $_ eq 'selected', $canvas->gettags($obj);
    my( $new_colour ); 
    if ($is_selected) {
        $new_colour = '#aaaaff';
        $canvas->dtag($obj, 'selected');
    } else {
        $new_colour = '#ffcccc';
        $canvas->addtag('selected', 'withtag', $obj);
    }
    $canvas->itemconfigure($obj,
        -fill => $new_colour,
        );
}

sub useage {
    exec('perldoc', $0);
}

sub make_chooser_map {
    my( $ensdb, $ctg_name ) = @_;
    
    reset_review_details_cache();
    my @map = get_fpc_contig_map($ensdb, $ctg_name);
    for (my $i = 0; $i < @map; $i++) {
        my $acc = $map[$i][0];
        if ($acc eq '__GAP__') {
            my $gap_size = $map[$i][1];
            $map[$i] = [ "GAP of ${gap_size}bp" ];
        } else {
            my $seq_name = seq_name_from_acc($acc) || $acc;
            $map[$i] = [review_details($seq_name)];
        }
    }
    
    if (my @unplaced = get_unplaced_clones(@map)) {
        push(@map, ['Unplaced clones']);
        foreach my $un (@unplaced) {
            push(@map, [review_details($un)]);
        }
    }
    
    return @map;
}

sub get_unplaced_clones {
    my( @map ) = @_;
    
    my %is_placed = map {$_->[1], 1} grep $_->[1], @map;
    my( @unplaced );
    foreach my $seq_name (list_all_seq_names())  {
        push(@unplaced, $seq_name) unless $is_placed{$seq_name};
    }
    return @unplaced;
}

{
    my( %seq_review_details );

    sub reset_review_details_cache {
        %seq_review_details = ();
    }

    sub list_all_seq_names {
        return sort keys %seq_review_details;
    }
    
    sub review_details {
        my( $seq_name ) = @_;

        unless (%seq_review_details) {
            print STDERR "Getting review details...";
            my $sql = qq{
                SELECT s.sequence_name
                  , a.ana_seq_id
                  , st.status_id
                  , r.annotator_uname
                  , r.review_time
                  , r.review_comment
                FROM sequence s
                  , ana_sequence a
                  , ana_status st
                  , species_chromosome c
                LEFT JOIN ana_sequence_review r
                  ON a.ana_seq_id = r.ana_seq_id
                WHERE s.seq_id = a.seq_id
                  AND a.ana_seq_id = st.ana_seq_id
                  AND s.chromosome_id = c.chromosome_id
                  AND a.is_current = 'Y'
                  AND st.is_current = 'Y'
                  AND c.chromosome_id = 20
                };
            my $sth = prepare_statement($sql);
            $sth->execute;
            while (my ($seq_name, @details) = $sth->fetchrow) {
                $seq_review_details{$seq_name} ||= [];
                push( @{$seq_review_details{$seq_name}}, [@details] );
            }
            print STDERR " got them\n";
        }
        my ($most_recent) = sort {$b->[3] cmp $a->[3]} @{$seq_review_details{$seq_name}};
        confess "No review data for '$seq_name'" unless $most_recent;
        my( $ana_seq_id, $status, $uname, $date, $comment ) = @$most_recent;
        ($date) = $date =~ /(\d{4}-\d\d-\d\d)/ if $date;
        $status = status_name($status);
        return( $ana_seq_id, $seq_name, $status, $uname, $date, $comment );
    }
}

{
    my( %id_status );
    
    sub status_name {
        my( $id ) = @_;
        
        unless (%id_status) {
            my $sth = prepare_statement(q{
                SELECT status_id
                  , status_name
                FROM ana_status_dict
                });
            $sth->execute;
            while (my( $id, $name ) = $sth->fetchrow) {
                $id_status{$id} = $name;
            }
        }
        return $id_status{$id};
    }
}

{
    my( %acc_seq );
    
    sub seq_name_from_acc {
        my( $acc ) = @_;
        
        unless (%acc_seq) {
            my $sth = prepare_statement(q{
                SELECT acc.accession
                  , s.sequence_name
                FROM project_acc acc
                  , project_dump d
                  , sequence s
                WHERE acc.sanger_id = d.sanger_id
                  AND d.seq_id = s.seq_id
                  AND d.is_current = 'Y'
                });
            $sth->execute();
            while (my($acc, $seq_name) = $sth->fetchrow) {
                $acc_seq{$acc} = $seq_name;
            }
        }
        return $acc_seq{$acc};
    }
}

{
    my( @map );
    
    sub get_fpc_contig_map {
        my( $ensdb, $ctg_name ) = @_;

        unless (@map) {
            print STDERR "Getting contig map...";
            my $sth = $ensdb->prepare(qq{
                SELECT c.id
                  , sgp.chr_start
                  , sgp.chr_end
                FROM static_golden_path sgp
                  , contig raw
                  , clone c
                WHERE sgp.raw_id = raw.internal_id
                  AND raw.clone = c.internal_id
                  AND sgp.fpcctg_name = '$ctg_name'
                  AND sgp.type = 'SANGER'
                ORDER BY sgp.chr_start ASC
                  , sgp.chr_end ASC
                });
            $sth->execute;
            my $prev_end = 0;
            while (my($acc, $start, $end) = $sth->fetchrow) {
                #printf("%12s  %5d  %5d\n", $acc, $start, $end);
                if (my $gap = $start - ($prev_end + 1)) {
                    #print "GAP  $gap\n";
                    push(@map, ['__GAP__', $gap]);
                }
                push(@map, [$acc, $start, $end]);
                $prev_end = $end;
            }
            $ensdb = undef; # Disconnect from the ensembl db
            print STDERR " done\n";
        }
        return @map;
    }
}

__END__

=head1 NAME - c20review

=head1 SYNOPISS

    c20review [-user <username>]

=head1 DESCRIPTION

Tracks who a reviewed the annotation of which
sequences on chromosome 20.

If the user is specified, then the interface
allows the database to be edited.

=head1 AUTHOR

James Gilbert B<email> jgrg@sanger.ac.uk

