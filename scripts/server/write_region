#!/usr/local/bin/perl -w

use OtterDefs;
use strict;

use CGI;

use Bio::Otter::AnnotationBroker;
use Bio::Otter::Converter;
use Bio::Otter::Lace::TempFile;
use Bio::Otter::CloneLockBroker;

use Bio::Otter::ServerSide qw(:all);

####################################################################
################ COMMON POST CGI SCRIPT BEGIN ######################
####################################################################

local $| = 1;

my $q = new CGI;
set_nph($q);

print STDERR "******* Starting to write region *********";

my $odb    = get_DBAdaptor_from_CGI_species($q, $OTTER_SPECIES);
my $author = get_Author_from_CGI($q);
####################################################################
####################################################################
####################################################################
# Get all the params in nice variables

my %params = $q->Vars;

my $xml_data  = $params{'data'}   || error_exit($q,"No xml data entered. Can't write region");
delete $params{'data'};
print STDERR "Length of data " . length($xml_data) . "";

my $auth_name = $author->name();
my $tmp_xml = Bio::Otter::Lace::TempFile->new;
$tmp_xml->root('/tmp');
$tmp_xml->name(qq`write_region_${auth_name}.xml`);
my $tmp_xml_name = $tmp_xml->full_name();
print STDERR "Writing xml to tmp file [$tmp_xml_name]";

my $xml_fh = eval{
    $tmp_xml->write_file_handle();
} || error_exit($q, "Can't write to '$tmp_xml_name' : $!");
print $xml_fh $xml_data;

# Save a bit of memory
$xml_data = undef;

print STDERR "Converting xml to otter...";
my $fh = $tmp_xml->read_file_handle();

####################################################################
################ COMMON POST CGI SCRIPT _END_ ######################
####################################################################

my( $genes, 
    $slice, # The slice is fetched from the database by XML_to_otter
    $path,
    $new_feature_set,   # Arrayref of SimpleFeature objects
    $chrname, $chrstart, $chrend,
    );
my $path_as_XML;
eval {
    my( $seqstr );  # Don't need outside block
    ($genes, $slice, $seqstr, $path, $new_feature_set) =
        Bio::Otter::Converter::XML_to_otter($fh, $odb);

    die "no path from XML"    unless  $path;
    die "empty path from XML" unless @$path;

    $chrname  = $slice->chr_name;
    $chrstart = $slice->chr_start;
    $chrend   = $slice->chr_end;

    $path_as_XML = Bio::Otter::Converter::path_to_XML($chrname, $chrstart, $chrend, $slice->assembly_type, $slice->get_tiling_path);

    print STDERR "Processed incoming xml file with slice: [$chrname] [$chrstart] [$chrend]"; 
};
if ($@) {
  print STDERR "Failed converting XML [$genes,$chrname,$chrstart,$chrend][$@]";
  error_exit($q, "Failed converting XML to otter [$@]");
}
print STDERR "done";

print STDERR "Found " . scalar(@$genes) . " genes on slice [$chrname] [$chrstart] [$chrend]";


my $cb = new Bio::Otter::CloneLockBroker($odb);


print STDERR "Checking region is locked...";
eval {
    $cb->check_locks_exist_by_slice($slice, $author);
};
error_exit($q, "Failed checking locks [$@]") if $@;
print STDERR "done";


# Get stable IDs for any genes, transcripts, translations and exons that don't have them
my $sida = $odb->get_StableIdAdaptor();
strip_incomplete_genes($genes);

foreach my $gene (@$genes) {    
    $gene->stable_id($sida->fetch_new_gene_stable_id)
        unless $gene->stable_id;
    foreach my $trans (@{$gene->get_all_Transcripts}) {
        $trans->stable_id($sida->fetch_new_transcript_stable_id)
            unless $trans->stable_id;
        if (my $translation = $trans->translation) {
            $translation->stable_id($sida->fetch_new_translation_stable_id)
                unless $translation->stable_id;
        }
        foreach my $exon (@{$trans->get_all_Exons}) {
            $exon->stable_id($sida->fetch_new_exon_stable_id)
                unless $exon->stable_id;
        }
    }
}

my $ab = new Bio::Otter::AnnotationBroker($odb);
$ab->current_author($author);
my $oaga = $odb->get_GeneAdaptor();
$odb->assembly_type($slice->assembly_type);

my $anal;

eval {
  $anal = $odb->get_AnalysisAdaptor()->fetch_by_logic_name('otter');
};

if ($@) {
  error_exit($q, "Failed fetching analysis [$@]");
}
if(!defined($anal)) {
  error_exit($q, "No analysis object associated with otter");
}

my $dbgenes;

print STDERR "Fetching database genes for comparison...";
eval {
  $dbgenes = $oaga->fetch_by_Slice($slice);
  strip_incomplete_genes($dbgenes);
};
if ($@) {
  error_exit($q, "Failed fetching genes [$@]");
}
print STDERR "done";

foreach my $gene (@$genes) {
  $gene->analysis($anal);
}


# These lines force loads from the database to stop attempted lazy
# loading during the write
eval {
  foreach my $gene (@$dbgenes) {
    my $transcripts = $gene->get_all_Transcripts;
    foreach my $tran (@$transcripts) {
      $tran->translation;
      if ($tran->translation) {
         $tran->translation->stable_id;
      }
      $tran->stable_id;
      my $exons =  $tran->get_all_Exons;
      foreach my $exon (@$exons) {
        $exon->stable_id;
      }
    }
  }
};
if ($@) {
  error_exit($q, "Failed fully loading genes before write [$@]");
}


my( @gene_events, @changed_clones );


print STDERR "Comparing " . scalar(@$dbgenes) . " old to " . scalar(@$genes) . " new gene(s)... ";

my( $del_sf, $save_sf );
eval {
    print STDERR "New clones";
    my $new_clones = clones_from_path($path);
    print STDERR "Old clones";
    my $old_clones = clones_from_path($slice->get_tiling_path);

    @gene_events = $ab->compare_genes($dbgenes, $genes);
    @changed_clones = $ab->compare_clones($old_clones, $new_clones);
    
    # $slice was fetched from the database by XML_to_otter, so we can simply:
    my $old_feature_set = $slice->get_all_SimpleFeatures;
    ($del_sf, $save_sf) = $ab->compare_feature_sets($old_feature_set, $new_feature_set);
};
if ($@) {
    error_exit($q, "Failed comparing annotations [$@]");
}
print STDERR "done";

# the magic happens!

my ($outputstr, $output_xml);
eval {
  $odb->begin_work();

  print STDERR "Found " . scalar(@gene_events) . " changed gene annotations";
  
  foreach my $event ( @gene_events ) {
    $outputstr .= $event->to_string;
    print STDERR $event->to_string;

    my $gene;

    if ($event->type eq 'deleted') {
      $gene = $event->old_gene;
    } else {
      $gene = $event->new_gene;
        $output_xml .= $gene->toXMLString();
    }

    print STDERR "Attaching gene to slice " . $gene->stable_id . " " . $gene->version. "";
    $oaga->attach_to_Slice($gene,$slice);
    $gene->detach_DBAdaptors;
    print STDERR "Done attaching";
    $oaga->store($gene);
    print STDERR "Stored gene";
    $outputstr .= " " . $gene->version . " " . $gene->gene_info->name->name . "";
  }
  
  my $oaca = $odb->get_CloneAdaptor;
  foreach my $clone (@changed_clones) {
    my $acc = $clone->embl_id;
    my $sv  = $clone->embl_version;
    printf STDERR "Storing new version of clone '$acc.$sv'";
    my $db_clone = $oaca->fetch_by_accession_version($acc, $sv);
    $db_clone->clone_info($clone->clone_info);
    $oaca->store($db_clone);
  }
    
    # Store SimpleFeature changes
    my $sfa = $odb->get_SimpleFeatureAdaptor;
    if (@$del_sf) {
        printf STDERR "Deleting %d SimpleFeatures", scalar @$del_sf;
        foreach my $sf (@$del_sf) {
            $sfa->remove($sf);
        }
    }
    if (@$save_sf) {
        attach_analysis_objects_and_transform_to_slice($odb, $slice, $save_sf);
        printf STDERR "Saving %d SimpleFeatures", scalar @$save_sf;
        $sfa->store(@$save_sf);
    }
  
  $odb->commit();
};

if ($@) {
  error_exit($q, "Failed writing annotations [$@]");
}

$outputstr ||= "No changes to annotations";
#send_response($q, $outputstr);
$output_xml = "<otter>\n" . $path_as_XML . $output_xml . "</otter>\n";
send_response($q, $output_xml);

#####################################################################################

sub clones_from_path {
    my( $path ) = @_;

    my $clones = [];
    foreach my $rawcontig (map $_->component_Seq, @$path) {
        my $clone = $rawcontig->clone;
        unless ($clone) {
            printf STDERR "No clone attached to '%s'", $rawcontig->id;
            next;
        }
        push(@$clones, $clone);
    }
    return $clones;
}

sub attach_analysis_objects_and_transform_to_slice {
    my( $dba, $slice, $sf_list ) = @_;

    my $analysis_adaptor = $dba->get_AnalysisAdaptor;
    
    my( %logic_ana );
    for (my $i = 0; $i < @$sf_list; $i++) {
        my $sf = $sf_list->[$i];
        my $class = ref($sf);
        my $logic_name = $sf->analysis->logic_name;
        my $ana = $logic_ana{$logic_name}
            ||= $analysis_adaptor->fetch_by_logic_name($logic_name);
        $sf->analysis($ana);
        $sf->contig($slice);
        my @mapped = $sf->transform;
        if (@mapped == 1) {
            unless ($mapped[0]->isa($class)) {
                die "Error, got '$mapped[0]' from transform";
            }
            $sf_list->[$i] = $mapped[0];
        } else {
            die "transform returned ", scalar(@mapped), " features: (@mapped)";
        }
    }
}

sub strip_incomplete_genes {
    my( $gene_list ) = @_;
    
    for (my $i = 0; $i < @$gene_list;) {
        my $gene = $gene_list->[$i];
        if ($gene->gene_info->truncated_flag) {
            printf STDERR "Splicing out incomplete gene '%s'", $gene->gene_info->name->name;
            splice(@$gene_list, $i, 1);
            next;
        } else {
            $i++;
        }
    }
}
