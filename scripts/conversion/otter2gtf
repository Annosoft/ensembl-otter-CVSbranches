#!/usr/local/bin/perl

use strict;

use Bio::Otter::DBSQL::DBAdaptor;
use Getopt::Long;
use Carp;
use FileHandle;

my $host   = 'ecs2a';
my $user   = 'ensro';
my $pass   = '';
my $port   = 3306;
my $dbname = 'otter_merged_chrs_with_anal';

my @chromosomes;
my $path = 'VEGA';
my $gtf_file = undef;
my $fix_phases = 0;

$| = 1;

&GetOptions(
  'host:s'        => \$host,
  'user:s'        => \$user,
  'dbname:s'      => \$dbname,
  'pass:s'        => \$pass,
  'path:s'        => \$path,
  'port:n'        => \$port,
  'chromosomes:s' => \@chromosomes,
  'gtffile:s'     => \$gtf_file,
  'fixphases'     => \$fix_phases,
);

if (scalar(@chromosomes)) {
  @chromosomes = split (/,/, join (',', @chromosomes));
}

my $db = new Bio::Otter::DBSQL::DBAdaptor(
  -host   => $host,
  -user   => $user,
  -port   => $port,
  -pass   => $pass,
  -dbname => $dbname
);
$db->assembly_type($path);

my $sa  = $db->get_SliceAdaptor();
my $aga = $db->get_AnnotatedGeneAdaptor();

my $chrhash = get_chrlengths($db,$path);

#filter to specified chromosome names only
if (scalar(@chromosomes)) {
  foreach my $chr (@chromosomes) {
    my $found = 0;
    foreach my $chr_from_hash (keys %$chrhash) {
      if ($chr_from_hash =~ /^${chr}$/) {
        $found = 1;
        last;
      }
    }
    if (!$found) {
      print "Didn't find chromosome named $chr in database $dbname\n";
    }
  }
  HASH: foreach my $chr_from_hash (keys %$chrhash) {
    foreach my $chr (@chromosomes) {
      if ($chr_from_hash =~ /^${chr}$/) { next HASH; }
    }
    delete($chrhash->{$chr_from_hash});
  }
}

my $gtffp = new FileHandle;
$gtffp->open(">$gtf_file") or croak "Unable to open $gtf_file for write";
$gtffp->autoflush(1);

foreach my $chr (reverse sort bychrnum keys %$chrhash) {
  print STDERR "Chr $chr from 1 to " . $chrhash->{$chr} . " on " . $path . "\n";
  my $chrstart = 1;
  my $chrend   = $chrhash->{$chr};
  #$chrend = 1000000;

  my $slice = $sa->fetch_by_chr_start_end($chr, 1, $chrend);

  print "Fetching genes\n";
  my $genes = $aga->fetch_by_Slice($slice);
  print "Done fetching genes\n";

  foreach my $gene (@$genes) {
    foreach my $trans (@{$gene->get_all_Transcripts}) {
      write_transcript_gtf($gtffp,$slice,$gene,$trans);
    }
  }
}

sub get_chrlengths{
  my $db = shift;
  my $type = shift;

  if (!$db->isa('Bio::EnsEMBL::DBSQL::DBAdaptor')) {
    die "get_chrlengths should be passed a Bio::EnsEMBL::DBSQL::DBAdaptor\n";
  }

  my %chrhash;

  my $q = qq( SELECT chrom.name,max(chr_end) FROM assembly as ass, chromosome as chrom
              WHERE ass.type = '$type' and ass.chromosome_id = chrom.chromosome_id
              GROUP BY chrom.name
            );

  my $sth = $db->prepare($q) || $db->throw("can't prepare: $q");
  my $res = $sth->execute || $db->throw("can't execute: $q");

  while( my ($chr, $length) = $sth->fetchrow_array) {
    $chrhash{$chr} = $length;
  }
  return \%chrhash;
}


sub bychrnum {

  my @awords = split /_/, $a;
  my @bwords = split /_/, $b;

  my $anum = $awords[0];
  my $bnum = $bwords[0];

  #  if ($anum !~ /^chr/ || $bnum !~ /^chr/) {
  #    die "Chr name doesn't begin with chr for $a or $b";
  #  }

  $anum =~ s/chr//;
  $bnum =~ s/chr//;

  if ($anum !~ /^[0-9]*$/) {
    if ($bnum !~ /^[0-9]*$/) {
      return $anum cmp $bnum;
    } else {
      return 1;
    }
  }
  if ($bnum !~ /^[0-9]*$/) {
    return -1;
  }

  if ($anum <=> $bnum) {
    return $anum <=> $bnum;
  } else {
    if ($#awords == 0) {
      return -1;
    } elsif ($#bwords == 0) {
      return 1;
    } else {
      return $awords[1] cmp $bwords[1];
    }
  }
}



sub get_start_and_end_as_features {
  my ($trans,$id) = @_;

  if (!$trans->translation) {
    return (undef, undef);
  }
  my @translateable = @{$trans->get_all_translateable_Exons};


  my $start_startc;
  my $end_startc;
  my $phase_startc;
  my $start_termc;
  my $end_termc;
  my $phase_termc;

  if ($translateable[0]->strand == 1) {
    $start_startc = $translateable[0]->start;
    $end_startc   = $translateable[0]->start+2;
    $phase_startc = $translateable[0]->phase;
    $phase_startc = $translateable[0]->phase != -1 ? $translateable[0]->phase : 0;

    #$start_termc = $translateable[$#translateable]->end+1;
    #$end_termc   = $translateable[$#translateable]->end+3;
    $start_termc = $translateable[$#translateable]->end-2;
    $end_termc   = $translateable[$#translateable]->end;
    $phase_termc = $translateable[$#translateable]->phase;
    $phase_termc = $translateable[$#translateable]->phase != -1 ? 
                     $translateable[$#translateable]->phase : 0;
  } else {
    $end_startc   = $translateable[0]->end;
    $start_startc = $translateable[0]->end-2;
    $phase_startc = $translateable[0]->phase != -1 ? $translateable[0]->phase : 0;

    #$start_termc = $translateable[$#translateable]->start-3;
    #$end_termc   = $translateable[$#translateable]->start-1;
    $start_termc = $translateable[$#translateable]->start;
    $end_termc   = $translateable[$#translateable]->start+2;
    $phase_termc = $translateable[$#translateable]->phase != -1 ? 
                     $translateable[$#translateable]->phase : 0;
  }

  my $startc = new Bio::EnsEMBL::SeqFeature(
                           -seqname => $id,
                           -source_tag => 'starttrans',
                           -primary_tag => 'similarity',
                           -start => $start_startc,
                           -end   => $end_startc,
                           -phase => $phase_startc,
                           -strand => $translateable[0]->strand);

  my $endc   = new Bio::EnsEMBL::SeqFeature(
                           -seqname => $id,
                           -source_tag => 'endtrans',
                           -primary_tag => 'similarity',
                           -start => $start_termc,
                           -end   => $end_termc,
                           -phase => $phase_termc,
                           -strand => $translateable[0]->strand);
  return ($startc,$endc);
}

sub write_transcript_gtf {
  my ($fh,$slice,$gene,$transcript) = @_;

  my ($startc, $endc) =  get_start_and_end_as_features($transcript,$transcript->stable_id);

  my $sliceoffset = $slice->chr_start-1;
  my $chrname;
  $chrname = $slice->chr_name;

  my $idstr = $chrname;

  my ($hasstart,$hasend) = check_start_and_stop($slice,$transcript);


  my @translateable_exons = @{$transcript->get_all_translateable_Exons} if $transcript->translation;


  if ($fix_phases) {
    my $phase = 0;
    foreach my $exon (@translateable_exons) {
      $exon->phase($phase);
      $exon->end_phase(($exon->length + $exon->phase) % 3);
      $phase = $exon->end_phase;
    }
  }

  my $count=1;
  my $intrans = 0;
  foreach my $exon (@{$transcript->get_all_Exons}) {
    my $strand = $exon->strand;
    if ($exon->strand == -1) {
        $strand = "-";
    } elsif ($exon->strand == 1) {
        $strand = "+";
    } elsif ($exon->strand == 0) {
        $strand = ".";
    }

    if ($transcript->translation && $exon == $transcript->translation->start_Exon) {
      $intrans = 1;
    }
    print $fh $idstr . "\t" . 
              $gene->type . "\t" . 
             'exon' . "\t" . 
             ($exon->start+$sliceoffset) . "\t". 
             ($exon->end+$sliceoffset) . "\t". 
             "." . "\t". 
             $strand . "\t". 
             "." . "\t";
    print_attribs($fh,$gene,$transcript,$count);
    if ($count == 1) { print_description_attribs($fh,$gene,$transcript,$count); }
    print $fh "\n";

    if ($intrans) {

      my $cdsexon = shift @translateable_exons;
      my $phase = $cdsexon->phase;
      if ($cdsexon->phase == 1) {
        $phase = 2;
      } elsif ($cdsexon->phase == 2) {
        $phase = 1;
      } elsif ($cdsexon->phase == -1) {
        $phase = 0;
      }
      my $exon_start = $cdsexon->start;
      my $exon_end   = $cdsexon->end;
      if ($transcript->translation && 
          $exon == $transcript->translation->end_Exon &&
          $hasend) {

        if ($cdsexon->strand == 1) {
          $exon_end = $cdsexon->end-3;
        } else {
          $exon_start = $cdsexon->start+3;
        }
      }
      if ($exon_start <= $cdsexon->end &&
          $exon_end >= $cdsexon->start) {
        print $fh $idstr . "\t" . 
                 $gene->type . "\t" . 
                 'CDS' . "\t" . 
                 ($exon_start+$sliceoffset) . "\t". 
                 ($exon_end+$sliceoffset) . "\t". 
                 "." . "\t". 
                 $strand . "\t". 
                 $phase . "\t";
        print_attribs($fh,$gene,$transcript,$count);
        print $fh "\n";
      }
    }
    if ($transcript->translation && 
        $exon == $transcript->translation->start_Exon && $hasstart) {
      print $fh $idstr . "\t" . 
               $gene->type . "\t" . 
               'start_codon' . "\t" . 
               ($startc->start+$sliceoffset) . "\t". 
               ($startc->end+$sliceoffset) . "\t". 
               "." . "\t". 
               $strand . "\t". 
               "0" . "\t";
      print_attribs($fh,$gene,$transcript,$count);
      print $fh "\n";
    }
    if ($transcript->translation && 
        $exon == $transcript->translation->end_Exon) {
      if ($hasend) {
        print $fh $idstr . "\t" . 
                 $gene->type . "\t" . 
                 'stop_codon' . "\t" . 
                 ($endc->start+$sliceoffset) . "\t". 
                 ($endc->end+$sliceoffset) . "\t". 
                 "." . "\t". 
                 $strand . "\t". 
                 "0" . "\t";
         print_attribs($fh,$gene,$transcript,$count);
         print $fh "\n";
      }
      $intrans = 0;
    }

    $count++;
  }
}

sub print_description_attribs {
  my ($fh,$gene,$transcript,$count) = @_;
  my $gene_description = undef;
  foreach my $remark ($gene->gene_info->remark) {
    $gene_description .= $remark->remark . " ";
  }
  if ($gene_description) {
    chop $gene_description;
    if ($gene_description eq "undef") {
      $gene_description = undef;
    }
  }
  my $trans_description = undef;
  foreach my $remark ($transcript->transcript_info->remark) {
    $trans_description .= $remark->remark . " ";
  }
  if ($trans_description) {
    chop $trans_description;
  }
  print $fh ($gene_description ? "gene_description \"$gene_description\"; " : "") .
            ($trans_description ? "trans_description \"$trans_description\"; " : "");
}

sub print_attribs {
  my ($fh,$gene,$transcript,$count) = @_;
  my $gene_name;
  if ($gene->gene_info->name && $gene->gene_info->name->name) {
    $gene_name = $gene->gene_info->name->name;
  } else {
    croak "Failed finding gene name for " .$gene->stable_id . "\n";
  }
  my $trans_name;
  if ($transcript->transcript_info->name) {
    $trans_name = $transcript->transcript_info->name;
  } else {
    croak "Failed finding transcript name for " .$transcript->stable_id . "\n";
  }


  print $fh "gene_id \"" .  $gene_name . "\"; " .
            "transcript_id \"" . $trans_name . "\"; " .
            "exon_number \"$count\"; " .
            "otter_gene_id \"" . $gene->stable_id . "\"; " .
            "otter_transcript_id \"" . $transcript->stable_id . "\"; ";
}

sub check_start_and_stop {
  my ($slice,$trans) = @_;

  if (!$trans->translation) {
    return (0, 0);
  }
  my @translateable = @{$trans->get_all_translateable_Exons};

  my $start_startc;
  my $end_startc;
  my $phase_startc;
  my $start_termc;
  my $end_termc;
  my $phase_termc;
  my $start_codon;
  my $stop_codon;


  if ($translateable[0]->strand == 1) {
    $start_startc = $translateable[0]->start;
    $end_startc   = $translateable[0]->start+2;
    $phase_startc = $translateable[0]->phase;

    #$start_termc = $translateable[$#translateable]->end+1;
    #$end_termc   = $translateable[$#translateable]->end+3;
    $start_termc = $translateable[$#translateable]->end-2;
    $end_termc   = $translateable[$#translateable]->end;
    $phase_termc = $translateable[$#translateable]->phase;

    # print "Forward strand start startc =  $start_startc end_startc = $end_startc start_termc = $start_termc end_termc = $end_termc\n";
    $start_codon = uc $slice->subseq($start_startc, $end_startc);
    $stop_codon  = uc $slice->subseq($start_termc, $end_termc);
  } else {
    $end_startc   = $translateable[0]->end;
    $start_startc = $translateable[0]->end-2;
    $phase_startc = $translateable[0]->phase;

    #$start_termc = $translateable[$#translateable]->start-3;
    #$end_termc   = $translateable[$#translateable]->start-1;
    $start_termc = $translateable[$#translateable]->start;
    $end_termc   = $translateable[$#translateable]->start+2;
    $phase_termc = $translateable[$#translateable]->phase;
    
    # print "Reverse strand start startc =  $start_startc end_startc = $end_startc start_termc = $start_termc end_termc = $end_termc\n";
   
    my $seqobj = Bio::PrimarySeq->new ( -seq => $slice->subseq($start_startc,$end_startc),
                              -moltype => 'dna'
                              );
    $start_codon = uc $seqobj->revcom->seq;
    $seqobj = Bio::PrimarySeq->new ( -seq => $slice->subseq($start_termc,$end_termc),
                              -moltype => 'dna'
                              );
    $stop_codon = uc $seqobj->revcom->seq;
  }

  # print "Start codon = $start_codon Stop codon = $stop_codon\n";

  my $hasstart = 0;
  if ($start_codon eq "ATG") {
    $hasstart = 1;
  }
  my $hasend = 0;
  if ($stop_codon eq "TGA" || $stop_codon eq "TAA" || $stop_codon eq "TAG") { 
    $hasend =  1;
  }
  # print ( $trans->transcript_info->name . " (" . $trans->stable_id . ") hasstart = $hasstart hasend = $hasend\n");
  return ($hasstart,$hasend);
}

